/*
 * Copyright (c) 2018 Madani Lainani
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <errno.h>
#include <device.h>
#include <gpio.h>
#include <soc.h>

struct gpio_sam4l_config {
	GpioPort *port;
};

#define DEV_CFG(dev) \
	((const struct gpio_sam4l_config *const)(dev)->config->config_info)

static int gpio_sam4l_config(struct device *dev, int access_op, u32_t pin,
			    int flags)
{
	const struct gpio_sam4l_config *config = DEV_CFG(dev);
	GpioPort *port = config->port;
	u32_t mask = 1 << pin;
	bool is_out = (flags & GPIO_DIR_MASK) == GPIO_DIR_OUT;
	int pud = flags & GPIO_PUD_MASK;

	if (access_op != GPIO_ACCESS_BY_PIN) {
		return -ENOTSUP;
	}

	if ((flags & GPIO_INT) != 0) {
		return -ENOTSUP;
	}

	if ((flags & GPIO_POL_MASK) != GPIO_POL_NORMAL) {
		return -ENOTSUP;
	}

	/* Direction */
	if (is_out) {
		port->reg.GPIO_ODERS = mask;
		/* Disable Schmitt trigger */
		port->reg.GPIO_STERC = mask;
	} else {
		port->reg.GPIO_ODERC = mask;
		/* Enable Schmitt trigger */
		port->reg.GPIO_STERS = mask;
	}

	/* Pull up / pull down */
	if (is_out && pud != GPIO_PUD_NORMAL) {
		return -ENOTSUP;
	}

	switch (pud) {
	case GPIO_PUD_NORMAL:
		break;
	case GPIO_PUD_PULL_UP:
		port->reg.GPIO_PDERC = mask;
		break;
	case GPIO_PUD_PULL_DOWN:
		port->reg.GPIO_PDERS = mask;
		break;
	default:
		return -ENOTSUP;
	}

	return 0;
}

static int gpio_sam4l_write(struct device *dev, int access_op, u32_t pin,
			   u32_t value)
{
	const struct gpio_sam4l_config *config = DEV_CFG(dev);
	GpioPort *port = config->port;
	u32_t mask = 1 << pin;

	if (access_op != GPIO_ACCESS_BY_PIN) {
		/* TODO(mlhx): support GPIO_ACCESS_BY_PORT */
		return -ENOTSUP;
	}

	if (value != 0) {
		port->reg.GPIO_OVRS = mask;
	} else {
		port->reg.GPIO_OVRC  = mask;
	}

	return 0;
}

static int gpio_sam4l_read(struct device *dev, int access_op, u32_t pin,
			  u32_t *value)
{
	const struct gpio_sam4l_config *config = DEV_CFG(dev);
	GpioPort *port = config->port;
	u32_t mask = 1 << pin;

	if (access_op != GPIO_ACCESS_BY_PIN) {
		/* TODO(mlhx): support GPIO_ACCESS_BY_PORT */
		return -ENOTSUP;
	}

	return port->reg.GPIO_PVR & mask;
}

static const struct gpio_driver_api gpio_sam4l_api = {
	.config = gpio_sam4l_config,
	.write = gpio_sam4l_write,
	.read = gpio_sam4l_read,
};

static int gpio_sam4l_init(struct device *dev)
{
	/*
	 * SAM4L Data Sheet Rev. H - section 23.5.2
	 * 
	 * The GPIO is connected to a Peripheral Bus clock (CLK_GPIO). This
	 * clock is generated by the Power Manager. CLK_GPIO is enabled at
	 * reset, and can be disabled by writing to the Power Manager. CLK_GPIO
	 * must be enabled in order to access the configuration registers of the
	 * GPIO or to use the GPIO interrupts. After configuring the GPIO, the
	 * CLK_GPIO can be disabled by writing to the Power Manager if
	 * interrupts are not used.
	 *
	 */

	return 0;
}

/* Port A */
#ifdef DT_GPIO_SAM_PORTA_BASE_ADDRESS

static const struct gpio_sam4l_config gpio_sam4l_config_0 = {
	.port = (GpioPort *)DT_GPIO_SAM_PORTA_BASE_ADDRESS,
};

DEVICE_AND_API_INIT(gpio_sam4l_0, DT_GPIO_SAM_PORTA_LABEL, gpio_sam4l_init,
		    NULL, &gpio_sam4l_config_0, POST_KERNEL,
		    CONFIG_KERNEL_INIT_PRIORITY_DEVICE, &gpio_sam4l_api);
#endif

/* Port B */
#ifdef DT_GPIO_SAM_PORTB_BASE_ADDRESS

static const struct gpio_sam4l_config gpio_sam4l_config_1 = {
	.port = (GpioPort *)DT_GPIO_SAM_PORTB_BASE_ADDRESS,
};

DEVICE_AND_API_INIT(gpio_sam4l_1, DT_GPIO_SAM_PORTB_LABEL, gpio_sam4l_init,
		    NULL, &gpio_sam4l_config_1, POST_KERNEL,
		    CONFIG_KERNEL_INIT_PRIORITY_DEVICE, &gpio_sam4l_api);
#endif

/* Port C */
#ifdef DT_GPIO_SAM_PORTC_BASE_ADDRESS

static const struct gpio_sam4l_config gpio_sam4l_config_2 = {
	.port = (GpioPort *)DT_GPIO_SAM_PORTC_BASE_ADDRESS,
};

DEVICE_AND_API_INIT(gpio_sam4l_2, DT_GPIO_SAM_PORTC_LABEL, gpio_sam4l_init,
		    NULL, &gpio_sam4l_config_2, POST_KERNEL,
		    CONFIG_KERNEL_INIT_PRIORITY_DEVICE, &gpio_sam4l_api);
#endif
